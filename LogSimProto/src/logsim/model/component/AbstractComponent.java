package logsim.model.component;

import logsim.log.Loggable;
import logsim.log.LoggableInt;
import logsim.log.Logger;
import logsim.model.Value;

/**
 * Egy komponens absztrakt megvalósítása, ebbõl származik az összes többi
 * komponens. A közös logikát valósítja meg. A gyakran használt dolgokra
 * ad alapértelmezett implementációt (összekötés, bemenetek kiértékelése stb.)
 */
public abstract class AbstractComponent implements Loggable {

    /**
     * Bemenetekre kötött vezetékek
     */
    protected Wire[] inputs;
    /**
     * Kimenetekre kötött vezetékek
     */
    protected Wire[] outputs;
    /**
     * Komponens neve
     */
    protected String name;
    /**
     * Változott-e a komponens kimenete
     */
    private boolean changed;

    /**
     * Konstruktor
     * @param name Komponens neve
     * @param inputCount Komponens bemeneteinek száma
     * @param outputCount Komponens kimeneteinek száma
     */
    protected AbstractComponent(String name, int inputCount, int outputCount) {
        this.name = name;
        Logger.logCreate(this);

        outputs = new Wire[outputCount];
        inputs = new Wire[inputCount];

        Logger.logReturn();
    }

    /**
     * Beállítunk egy bemenetet
     *
     * @param inputPin Melyik bemenetet állítjuk
     * @param wire Melyik vezetéket kötjük rá
     */
    public void setInput(int inputPin, Wire wire) {
        Logger.logCall(this, "setInput", new LoggableInt(inputPin), wire);
        inputs[inputPin - 1] = wire;
        Logger.logReturn();
    }

    protected Wire getInputWire(int inputPin) {
        return inputs[inputPin - 1];
    }

    protected int getInputsCount() {
        return inputs.length;
    }

    /**
     * Beállítunk egy kimenetet
     * @param outputPin Melyik kimenetet állítjuk
     * @param wire Melyik vezetéket kötjük rá
     */
    public void setOutput(int outputPin, Wire wire) {
        Logger.logCall(this, "setOutput", new LoggableInt(outputPin), wire);
        outputs[outputPin - 1] = wire;
        Logger.logReturn();
    }

    protected Wire getOutputWire(int outputPin) {
        return outputs[outputPin - 1];
    }

    protected int getOutputsCount() {
        return outputs.length;
    }

    /**
     * Komponens kimeneti lábain lévõ vezetékeken lévõ értékek újraszámolása
     * a bemenetek alapján.
     *
     */
    public void evaluate() {
        Logger.logCall(this, "evaluate");

        changed = false;
        Value[] oldValues = new Value[outputs.length];
        for (int i = 0; i < outputs.length; i++) {
            if (outputs[i] != null) {
                oldValues[i] = outputs[i].getValue();
            }
        }

        onEvaluation();

        for (int i = 0; i < outputs.length; i++) {
            if (outputs[i] != null && oldValues[i] != outputs[i].getValue()) {
                changed = true;
                break;
            }
        }

        Logger.logReturn();
    }

    /**
     * Lekérjük egy adott bemenetre kötött értéket
     *
     * @param inputPin Bemenet, amely érdekel minket
     * @return Bementen lévõ érték
     */
    protected Value getInput(int inputPin) {
        return inputs[inputPin - 1].getValue();
    }

    /**
     * Visszaadja, hogy a komponensünk kimeneti értéke változott-e a kiértékelés során
     * @return Változott-e
     */
    public boolean isChanged() {
        return changed;
    }

    /**
     * Ebben a metódusban kell implementálni az alkatrész logikáját, vagyis
     * az adott bemenet(ek) függvényében mit kell kiadnia a kimenet(ek)re.
     */
    protected abstract void onEvaluation();

    /**
     * Lemásoljuk a komponenst. Ezt a kompozitoknál használjuk!
     *
     * @return másolat
     */
    public abstract AbstractComponent copy(String newName);

    /**
     * Komponens hozzáadása az áramkörhöz
     * @param composite Áramkör, amihez hozzáadjuk
     */
    public void addTo(Composite composite) {
        Logger.logCall(this, "addTo", composite);
        composite.add(this);
        Logger.logReturn();
    }

    public Wire[] getInputsWire()
    {
        return inputs;
    }

    public Wire[] getOutputsWire()
    {
        return outputs;
    }

    @Override
    public String getName() {
        return name;
    }
}
